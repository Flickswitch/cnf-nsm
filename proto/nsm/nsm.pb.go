// Code generated by protoc-gen-go. DO NOT EDIT.
// source: nsm/nsm.proto

package nsm

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Corresponds to "MechanismType" from NSM terminology.
type ConnectionInterfaceType int32

const (
	ConnectionInterfaceType_DEFAULT_INTERFACE ConnectionInterfaceType = 0
	ConnectionInterfaceType_KERNEL_INTERFACE  ConnectionInterfaceType = 1
	ConnectionInterfaceType_MEM_INTERFACE     ConnectionInterfaceType = 3
)

var ConnectionInterfaceType_name = map[int32]string{
	0: "DEFAULT_INTERFACE",
	1: "KERNEL_INTERFACE",
	3: "MEM_INTERFACE",
}

var ConnectionInterfaceType_value = map[string]int32{
	"DEFAULT_INTERFACE": 0,
	"KERNEL_INTERFACE":  1,
	"MEM_INTERFACE":     3,
}

func (x ConnectionInterfaceType) String() string {
	return proto.EnumName(ConnectionInterfaceType_name, int32(x))
}

func (ConnectionInterfaceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4af62f758d03b601, []int{0}
}

// Labels assigned to a connection either from the client or from the endpoint side.
type ConnectionLabel struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectionLabel) Reset()         { *m = ConnectionLabel{} }
func (m *ConnectionLabel) String() string { return proto.CompactTextString(m) }
func (*ConnectionLabel) ProtoMessage()    {}
func (*ConnectionLabel) Descriptor() ([]byte, []int) {
	return fileDescriptor_4af62f758d03b601, []int{0}
}

func (m *ConnectionLabel) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConnectionLabel.Unmarshal(m, b)
}
func (m *ConnectionLabel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConnectionLabel.Marshal(b, m, deterministic)
}
func (m *ConnectionLabel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionLabel.Merge(m, src)
}
func (m *ConnectionLabel) XXX_Size() int {
	return xxx_messageInfo_ConnectionLabel.Size(m)
}
func (m *ConnectionLabel) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionLabel.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionLabel proto.InternalMessageInfo

func (m *ConnectionLabel) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *ConnectionLabel) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Client connected to a selected Network Service.
type NetworkServiceClient struct {
	// Name of the client (not part of the NSM protocol, used only for identification within the Ligato CNF-Agent).
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Name of the network service to connect the client into.
	NetworkService string `protobuf:"bytes,2,opt,name=network_service,json=networkService,proto3" json:"network_service,omitempty"`
	// Labels to be sent with the NS connection request.
	OutgoingLabels []*ConnectionLabel `protobuf:"bytes,3,rep,name=outgoing_labels,json=outgoingLabels,proto3" json:"outgoing_labels,omitempty"`
	// Name assigned to the interface created for the connection.
	InterfaceName string `protobuf:"bytes,4,opt,name=interface_name,json=interfaceName,proto3" json:"interface_name,omitempty"`
	// Type of the interface created for the connection.
	InterfaceType ConnectionInterfaceType `protobuf:"varint,5,opt,name=interface_type,json=interfaceType,proto3,enum=upnp.ConnectionInterfaceType" json:"interface_type,omitempty"`
	// List of IP addresses (with prefixes) attached to the interface created for the connection.
	IpAddresses []string `protobuf:"bytes,6,rep,name=ip_addresses,json=ipAddresses,proto3" json:"ip_addresses,omitempty"`
	// MAC address to assign to the connection interface. Leave empty to automatically generate.
	PhysAddress          string   `protobuf:"bytes,7,opt,name=phys_address,json=physAddress,proto3" json:"phys_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkServiceClient) Reset()         { *m = NetworkServiceClient{} }
func (m *NetworkServiceClient) String() string { return proto.CompactTextString(m) }
func (*NetworkServiceClient) ProtoMessage()    {}
func (*NetworkServiceClient) Descriptor() ([]byte, []int) {
	return fileDescriptor_4af62f758d03b601, []int{1}
}

func (m *NetworkServiceClient) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkServiceClient.Unmarshal(m, b)
}
func (m *NetworkServiceClient) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkServiceClient.Marshal(b, m, deterministic)
}
func (m *NetworkServiceClient) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkServiceClient.Merge(m, src)
}
func (m *NetworkServiceClient) XXX_Size() int {
	return xxx_messageInfo_NetworkServiceClient.Size(m)
}
func (m *NetworkServiceClient) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkServiceClient.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkServiceClient proto.InternalMessageInfo

func (m *NetworkServiceClient) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NetworkServiceClient) GetNetworkService() string {
	if m != nil {
		return m.NetworkService
	}
	return ""
}

func (m *NetworkServiceClient) GetOutgoingLabels() []*ConnectionLabel {
	if m != nil {
		return m.OutgoingLabels
	}
	return nil
}

func (m *NetworkServiceClient) GetInterfaceName() string {
	if m != nil {
		return m.InterfaceName
	}
	return ""
}

func (m *NetworkServiceClient) GetInterfaceType() ConnectionInterfaceType {
	if m != nil {
		return m.InterfaceType
	}
	return ConnectionInterfaceType_DEFAULT_INTERFACE
}

func (m *NetworkServiceClient) GetIpAddresses() []string {
	if m != nil {
		return m.IpAddresses
	}
	return nil
}

func (m *NetworkServiceClient) GetPhysAddress() string {
	if m != nil {
		return m.PhysAddress
	}
	return ""
}

// Endpoint advertised within the selected Network Service.
type NetworkServiceEndpoint struct {
	// Name of the network service where the endpoint is announced.
	// At most once endpoint is possible to register for a given network service. This limitation is imposed
	// by the design of NSM - all requests for connection with an endpoint goes through the same link (unix socket)
	// and there is not enough information inside request contexts to be able to dissect them between multiple endpoints.
	NetworkService string `protobuf:"bytes,2,opt,name=network_service,json=networkService,proto3" json:"network_service,omitempty"`
	// Labels advertised by this endpoint.
	AdvertisedLabels []*ConnectionLabel `protobuf:"bytes,3,rep,name=advertised_labels,json=advertisedLabels,proto3" json:"advertised_labels,omitempty"`
	// If enabled, only single client is expected to connect. Further connection requests will be declined.
	SingleClient bool `protobuf:"varint,4,opt,name=single_client,json=singleClient,proto3" json:"single_client,omitempty"`
	// Prefix of the name assigned to interface created for every connection.
	// The interface name suffix will be either taken from the client's outgoing label if interface_name_suffix_from_label
	// is defined, or the first unused unsigned integer (i.e. starting with 0) will be appended.
	// For example, with interface_name_prefix="nsm" and interface_name_suffix_from_label undefined, interfaces
	// created for connected clients will be "nsm0", "nsm1", etc.
	InterfaceNamePrefix string `protobuf:"bytes,5,opt,name=interface_name_prefix,json=interfaceNamePrefix,proto3" json:"interface_name_prefix,omitempty"`
	// By default, interface names are suffixed with integer indexes, starting from 0 (i.e. <prefix>0, <prefix>1, etc.)
	// The disadvantage of this approach is that associations between interface names and opposing clients will depend
	// on the order in which the clients are being (dis)connected, which in most cases is not deterministic.
	// As an alternative, it is possible to use value of a client's outgoing label with the given key.
	// For example, if client is defined with outgoing label "app"="nat" and interface_name_prefix="conn-", then
	// if interface_name_suffix_from_label="app" the resulting interface name will be "conn-nat".
	// If client doesn't define outgoing label with such key, the connection request will be declined.
	InterfaceNameSuffixFromLabel string `protobuf:"bytes,6,opt,name=interface_name_suffix_from_label,json=interfaceNameSuffixFromLabel,proto3" json:"interface_name_suffix_from_label,omitempty"`
	// Type of the interface created for the connection.
	InterfaceType ConnectionInterfaceType `protobuf:"varint,7,opt,name=interface_type,json=interfaceType,proto3,enum=upnp.ConnectionInterfaceType" json:"interface_type,omitempty"`
	// List of IP addresses (with prefixes) attached to the interface created for the connection.
	// Supported only with single connected client (single_client=true).
	IpAddresses []string `protobuf:"bytes,8,rep,name=ip_addresses,json=ipAddresses,proto3" json:"ip_addresses,omitempty"`
	// MAC address to assign to the connection interface. Leave empty to automatically generate.
	// Supported only with single connected client (single_client=true).
	PhysAddress          string   `protobuf:"bytes,9,opt,name=phys_address,json=physAddress,proto3" json:"phys_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkServiceEndpoint) Reset()         { *m = NetworkServiceEndpoint{} }
func (m *NetworkServiceEndpoint) String() string { return proto.CompactTextString(m) }
func (*NetworkServiceEndpoint) ProtoMessage()    {}
func (*NetworkServiceEndpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_4af62f758d03b601, []int{2}
}

func (m *NetworkServiceEndpoint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkServiceEndpoint.Unmarshal(m, b)
}
func (m *NetworkServiceEndpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkServiceEndpoint.Marshal(b, m, deterministic)
}
func (m *NetworkServiceEndpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkServiceEndpoint.Merge(m, src)
}
func (m *NetworkServiceEndpoint) XXX_Size() int {
	return xxx_messageInfo_NetworkServiceEndpoint.Size(m)
}
func (m *NetworkServiceEndpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkServiceEndpoint.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkServiceEndpoint proto.InternalMessageInfo

func (m *NetworkServiceEndpoint) GetNetworkService() string {
	if m != nil {
		return m.NetworkService
	}
	return ""
}

func (m *NetworkServiceEndpoint) GetAdvertisedLabels() []*ConnectionLabel {
	if m != nil {
		return m.AdvertisedLabels
	}
	return nil
}

func (m *NetworkServiceEndpoint) GetSingleClient() bool {
	if m != nil {
		return m.SingleClient
	}
	return false
}

func (m *NetworkServiceEndpoint) GetInterfaceNamePrefix() string {
	if m != nil {
		return m.InterfaceNamePrefix
	}
	return ""
}

func (m *NetworkServiceEndpoint) GetInterfaceNameSuffixFromLabel() string {
	if m != nil {
		return m.InterfaceNameSuffixFromLabel
	}
	return ""
}

func (m *NetworkServiceEndpoint) GetInterfaceType() ConnectionInterfaceType {
	if m != nil {
		return m.InterfaceType
	}
	return ConnectionInterfaceType_DEFAULT_INTERFACE
}

func (m *NetworkServiceEndpoint) GetIpAddresses() []string {
	if m != nil {
		return m.IpAddresses
	}
	return nil
}

func (m *NetworkServiceEndpoint) GetPhysAddress() string {
	if m != nil {
		return m.PhysAddress
	}
	return ""
}

func init() {
	proto.RegisterEnum("upnp.ConnectionInterfaceType", ConnectionInterfaceType_name, ConnectionInterfaceType_value)
	proto.RegisterType((*ConnectionLabel)(nil), "upnp.ConnectionLabel")
	proto.RegisterType((*NetworkServiceClient)(nil), "upnp.NetworkServiceClient")
	proto.RegisterType((*NetworkServiceEndpoint)(nil), "upnp.NetworkServiceEndpoint")
}

func init() {
	proto.RegisterFile("nsm/nsm.proto", fileDescriptor_4af62f758d03b601)
}

var fileDescriptor_4af62f758d03b601 = []byte{
	// 481 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x53, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0x25, 0x75, 0x9a, 0x36, 0x93, 0xe6, 0x6b, 0x49, 0xc0, 0x07, 0x90, 0x4c, 0x10, 0x22, 0x42,
	0xc2, 0x95, 0xc2, 0x09, 0x21, 0x21, 0xa5, 0xa9, 0x23, 0x55, 0xa4, 0x11, 0x72, 0xc3, 0x01, 0x2e,
	0x96, 0x6b, 0x8f, 0xc3, 0xaa, 0xf6, 0xee, 0xca, 0xeb, 0x84, 0xe6, 0x6f, 0xf1, 0x23, 0xf8, 0x5d,
	0x68, 0xd7, 0x0e, 0xc4, 0xa9, 0x10, 0x3d, 0xf4, 0xb6, 0xf3, 0xfc, 0x66, 0xe6, 0xe9, 0x3d, 0x0f,
	0x34, 0x99, 0x4c, 0x4e, 0x99, 0x4c, 0x6c, 0x91, 0xf2, 0x8c, 0x93, 0xea, 0x4a, 0x30, 0x31, 0x78,
	0x0f, 0xed, 0x09, 0x67, 0x0c, 0x83, 0x8c, 0x72, 0x36, 0xf3, 0xaf, 0x31, 0x26, 0x1d, 0x30, 0x6e,
	0x70, 0x63, 0x56, 0xac, 0xca, 0xb0, 0xee, 0xaa, 0x27, 0xe9, 0xc1, 0xe1, 0xda, 0x8f, 0x57, 0x68,
	0x1e, 0x68, 0x2c, 0x2f, 0x06, 0xbf, 0x0e, 0xa0, 0x37, 0xc7, 0xec, 0x07, 0x4f, 0x6f, 0xae, 0x30,
	0x5d, 0xd3, 0x00, 0x27, 0x31, 0x45, 0x96, 0x11, 0x02, 0x55, 0xe6, 0x27, 0x58, 0x4c, 0xd0, 0x6f,
	0xf2, 0x1a, 0xda, 0x2c, 0xe7, 0x7a, 0x32, 0x27, 0x17, 0xc3, 0x5a, 0xac, 0x34, 0x82, 0x7c, 0x84,
	0x36, 0x5f, 0x65, 0x4b, 0x4e, 0xd9, 0xd2, 0x8b, 0x95, 0x1e, 0x69, 0x1a, 0x96, 0x31, 0x6c, 0x8c,
	0xfa, 0xb6, 0x12, 0x6c, 0xef, 0xa9, 0x75, 0x5b, 0x5b, 0xb6, 0x2e, 0x25, 0x79, 0x05, 0x2d, 0xca,
	0x32, 0x4c, 0x23, 0x3f, 0x40, 0x4f, 0xcb, 0xa8, 0xea, 0x3d, 0xcd, 0x3f, 0xe8, 0x5c, 0xe9, 0x39,
	0xdf, 0xa5, 0x65, 0x1b, 0x81, 0xe6, 0xa1, 0x55, 0x19, 0xb6, 0x46, 0xcf, 0xf7, 0xb7, 0x5c, 0x6c,
	0x59, 0x8b, 0x8d, 0xc0, 0x9d, 0x29, 0xaa, 0x24, 0x2f, 0xe0, 0x84, 0x0a, 0xcf, 0x0f, 0xc3, 0x14,
	0xa5, 0x44, 0x69, 0xd6, 0x2c, 0x63, 0x58, 0x77, 0x1b, 0x54, 0x8c, 0xb7, 0x90, 0xa2, 0x88, 0xef,
	0x1b, 0xb9, 0x25, 0x99, 0x47, 0x5a, 0x4d, 0x43, 0x61, 0x05, 0x69, 0xf0, 0xd3, 0x80, 0x27, 0x65,
	0x23, 0x1d, 0x16, 0x0a, 0x4e, 0x59, 0x76, 0x7f, 0xdb, 0xce, 0xa0, 0xeb, 0x87, 0x6b, 0x4c, 0x33,
	0x2a, 0x31, 0xbc, 0x97, 0x71, 0x9d, 0xbf, 0xfc, 0xc2, 0xba, 0x97, 0xd0, 0x94, 0x94, 0x2d, 0x63,
	0xf4, 0x02, 0x1d, 0xa4, 0x76, 0xee, 0xd8, 0x3d, 0xc9, 0xc1, 0x22, 0xdc, 0x11, 0xf4, 0xcb, 0xfe,
	0x7a, 0x22, 0xc5, 0x88, 0xde, 0x6a, 0xff, 0xea, 0xee, 0xe3, 0x92, 0xcd, 0x9f, 0xf5, 0x27, 0x32,
	0x05, 0x6b, 0xaf, 0x47, 0xae, 0xa2, 0x88, 0xde, 0x7a, 0x51, 0xca, 0x93, 0x5c, 0xac, 0x59, 0xd3,
	0xed, 0xcf, 0x4a, 0xed, 0x57, 0x9a, 0x35, 0x4d, 0x79, 0x92, 0xff, 0x99, 0x77, 0x43, 0x3b, 0x7a,
	0x80, 0xd0, 0x8e, 0xff, 0x1f, 0x5a, 0xfd, 0x4e, 0x68, 0x6f, 0xbe, 0xc2, 0xd3, 0x7f, 0xec, 0x23,
	0x7d, 0xe8, 0x9e, 0x3b, 0xd3, 0xf1, 0x97, 0xd9, 0xc2, 0xbb, 0x98, 0x2f, 0x1c, 0x77, 0x3a, 0x9e,
	0x38, 0x9d, 0x47, 0xa4, 0x07, 0x9d, 0x4f, 0x8e, 0x3b, 0x77, 0x66, 0x3b, 0x68, 0x85, 0x74, 0xa1,
	0x79, 0xe9, 0x5c, 0xee, 0x40, 0xc6, 0xd9, 0xe0, 0x9b, 0xb5, 0xe4, 0x76, 0x10, 0xb2, 0xc8, 0xa6,
	0xfc, 0x34, 0x60, 0xd1, 0x5b, 0x75, 0xb9, 0xfa, 0x6a, 0xd5, 0xfd, 0x7e, 0x60, 0x32, 0xb9, 0xae,
	0xe9, 0xf2, 0xdd, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0xde, 0xc8, 0x42, 0xa3, 0xd5, 0x03, 0x00,
	0x00,
}
